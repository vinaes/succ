import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { spawn, execFileSync } from 'child_process';
import { logError, logWarn } from '../lib/fault-logger.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface HookOutput {
  hookSpecificOutput?: {
    hookEventName?: string;
    additionalContext?: string;
  };
}

export interface CodexChatOptions {
  project?: string;
  codexBin?: string;
  noBrief?: boolean;
  noEndHook?: boolean;
}

function resolveCodexBin(customBin?: string): string {
  if (customBin) {
    if (fs.existsSync(customBin)) return customBin;
    throw new Error(`Custom codex binary not found: ${customBin}`);
  }

  // Check if codex is available on PATH
  const cmd = process.platform === 'win32' ? 'where' : 'which';
  const bin = process.platform === 'win32' ? 'codex.cmd' : 'codex';
  try {
    execFileSync(cmd, [bin], { stdio: 'pipe' });
    return bin;
  } catch {
    throw new Error(
      'Codex CLI not found on PATH. Install it (https://github.com/openai/codex) or pass --codex-bin <path>.'
    );
  }
}

function hooksPath(name: string): string {
  return path.resolve(__dirname, '..', '..', 'hooks', name);
}

async function runHook(
  name: string,
  payload: Record<string, unknown>
): Promise<string | undefined> {
  const script = hooksPath(name);
  if (!fs.existsSync(script)) return undefined;

  return await new Promise<string | undefined>((resolve) => {
    const child = spawn(process.execPath, [script], { stdio: ['pipe', 'pipe', 'inherit'] });
    let out = '';
    child.stdout.on('data', (chunk: Buffer) => {
      out += chunk.toString();
    });
    child.on('close', () => {
      try {
        const parsed: HookOutput = JSON.parse(out.trim() || '{}');
        resolve(parsed.hookSpecificOutput?.additionalContext);
      } catch (err) {
        logWarn('codex-chat', `Failed to parse hook output for ${name}: ${(err as Error).message}`);
        resolve(undefined);
      }
    });
    child.stdin.write(JSON.stringify(payload));
    child.stdin.end();
  });
}

const SUCC_START_MARKER = '<!-- succ:start -->';
const SUCC_END_MARKER = '<!-- succ:end -->';

/**
 * Write succ context into AGENTS.md at project root.
 * Uses <!-- succ:start/end --> markers to preserve user content.
 * Codex reads AGENTS.md from repo root as role=user instructions.
 */
async function generateAgentsMd(projectDir: string): Promise<void> {
  const additionalContext = await runHook('succ-session-start.cjs', { cwd: projectDir });
  if (!additionalContext) {
    logWarn('codex-chat', 'No briefing from session-start hook, skipping AGENTS.md generation');
    return;
  }

  const agentsPath = path.join(projectDir, 'AGENTS.md');
  const succBlock = [
    SUCC_START_MARKER,
    '<!-- AUTO-GENERATED by succ. Do not edit between these markers. -->',
    '<!-- Regenerated on each `succ codex-chat` launch with fresh context. -->',
    '',
    additionalContext,
    SUCC_END_MARKER,
  ].join('\n');

  if (fs.existsSync(agentsPath)) {
    // Preserve user content, replace only succ block
    const existing = fs.readFileSync(agentsPath, 'utf8');
    const startIdx = existing.indexOf(SUCC_START_MARKER);
    const endIdx = existing.indexOf(SUCC_END_MARKER);

    if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
      // Replace existing succ block
      const before = existing.slice(0, startIdx);
      const after = existing.slice(endIdx + SUCC_END_MARKER.length);
      fs.writeFileSync(agentsPath, before + succBlock + after);
    } else {
      // Append succ block to end
      const separator = existing.endsWith('\n') ? '\n' : '\n\n';
      fs.writeFileSync(agentsPath, existing + separator + succBlock + '\n');
    }
  } else {
    fs.writeFileSync(agentsPath, succBlock + '\n');
  }

  console.log(`  Updated ${agentsPath}`);
}

export async function codexChat(options: CodexChatOptions): Promise<void> {
  const projectDir = options.project ? path.resolve(options.project) : process.cwd();

  // Resolve codex binary
  let codexBin: string;
  try {
    codexBin = resolveCodexBin(options.codexBin);
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    logError('codex-chat', message);
    console.error(`\n  Error: ${message}\n`);
    process.exitCode = 1;
    return;
  }

  // Generate fresh .succ/AGENTS.md with session context
  if (!options.noBrief) {
    try {
      console.log('  Generating succ context for Codex...');
      await generateAgentsMd(projectDir);
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);
      logWarn('codex-chat', `Failed to generate AGENTS.md: ${msg}`);
      console.error(`  Warning: could not generate AGENTS.md: ${msg}`);
    }
  }

  // Spawn codex with stdio passthrough — no PTY needed
  console.log('  Launching Codex...\n');
  const child = spawn(codexBin, [], {
    stdio: 'inherit',
    cwd: projectDir,
    env: process.env,
    shell: process.platform === 'win32',
  });

  // On Windows, Ctrl+C goes to the entire console process group.
  // Ignore SIGINT in the parent — let the child (Codex) handle it.
  // This avoids EPERM errors from Codex's own signal forwarding on Windows.
  const sigintHandler = () => {};
  if (process.platform === 'win32') {
    process.on('SIGINT', sigintHandler);
  }

  child.on('close', async (code) => {
    // Restore default SIGINT handling
    process.removeListener('SIGINT', sigintHandler);

    // Run session-end hook for cleanup
    if (!options.noEndHook) {
      try {
        await runHook('succ-session-end.cjs', { cwd: projectDir });
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        logWarn('codex-chat', `session-end hook error: ${msg}`);
      }
    }
    process.exitCode = code ?? 0;
  });

  child.on('error', (err) => {
    logError('codex-chat', `Failed to spawn codex: ${err.message}`);
    console.error(`\n  Error: Failed to spawn codex: ${err.message}\n`);
    process.exitCode = 1;
  });
}
