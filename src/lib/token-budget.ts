/**
 * Token Budget Tracker
 *
 * Tracks cumulative token usage per daemon session for:
 * - Smarter observer extraction triggers (real tokens vs byte estimate)
 * - Cost reporting (extraction + synthesis LLM calls)
 * - Session-level analytics
 *
 * State is ephemeral (in-memory per daemon process).
 * Persisted to .succ/session-tokens.json on flush.
 */

import fs from 'fs';
import path from 'path';
import { countTokens } from './token-counter.js';
import { getSuccDir } from './config.js';

export interface TokenBudgetEntry {
  /** Tokens in transcript since last observation */
  transcriptTokens: number;
  /** Tokens consumed by LLM extraction calls */
  extractionInputTokens: number;
  /** Tokens generated by LLM extraction */
  extractionOutputTokens: number;
  /** Tokens consumed by LLM synthesis calls */
  synthesisInputTokens: number;
  /** Tokens generated by LLM synthesis */
  synthesisOutputTokens: number;
  /** Number of facts extracted */
  factsExtracted: number;
  /** Number of facts saved (after dedup/quality filter) */
  factsSaved: number;
  /** Timestamp of last update */
  lastUpdate: number;
}

// In-memory state: sessionId → budget
const budgets = new Map<string, TokenBudgetEntry>();

function createEmptyBudget(): TokenBudgetEntry {
  return {
    transcriptTokens: 0,
    extractionInputTokens: 0,
    extractionOutputTokens: 0,
    synthesisInputTokens: 0,
    synthesisOutputTokens: 0,
    factsExtracted: 0,
    factsSaved: 0,
    lastUpdate: Date.now(),
  };
}

/**
 * Get or create budget for a session.
 */
export function getBudget(sessionId: string): TokenBudgetEntry {
  if (!budgets.has(sessionId)) {
    budgets.set(sessionId, createEmptyBudget());
  }
  return budgets.get(sessionId)!;
}

/**
 * Record new transcript content tokens.
 * Called by the observer when reading new transcript content.
 */
export function recordTranscriptTokens(sessionId: string, text: string): number {
  const budget = getBudget(sessionId);
  const tokens = countTokens(text);
  budget.transcriptTokens += tokens;
  budget.lastUpdate = Date.now();
  return tokens;
}

/**
 * Record extraction LLM usage.
 * Called after extractSessionSummary completes.
 */
export function recordExtraction(
  sessionId: string,
  inputTokens: number,
  outputTokens: number,
  factsExtracted: number,
  factsSaved: number
): void {
  const budget = getBudget(sessionId);
  budget.extractionInputTokens += inputTokens;
  budget.extractionOutputTokens += outputTokens;
  budget.factsExtracted += factsExtracted;
  budget.factsSaved += factsSaved;
  budget.lastUpdate = Date.now();
}

/**
 * Record synthesis LLM usage.
 * Called after reflection synthesis completes.
 */
export function recordSynthesis(
  sessionId: string,
  inputTokens: number,
  outputTokens: number
): void {
  const budget = getBudget(sessionId);
  budget.synthesisInputTokens += inputTokens;
  budget.synthesisOutputTokens += outputTokens;
  budget.lastUpdate = Date.now();
}

/**
 * Get total LLM tokens consumed by this session (input + output).
 */
export function getTotalLLMTokens(sessionId: string): number {
  const budget = getBudget(sessionId);
  return budget.extractionInputTokens + budget.extractionOutputTokens +
         budget.synthesisInputTokens + budget.synthesisOutputTokens;
}

/**
 * Check if a session has reached the transcript token threshold.
 * Used by the observer to decide when to extract.
 */
export function hasReachedTokenThreshold(sessionId: string, threshold: number): boolean {
  const budget = getBudget(sessionId);
  return budget.transcriptTokens >= threshold;
}

/**
 * Reset transcript token counter after extraction.
 * Called by the observer after successful extraction.
 */
export function resetTranscriptCounter(sessionId: string): void {
  const budget = getBudget(sessionId);
  budget.transcriptTokens = 0;
  budget.lastUpdate = Date.now();
}

/**
 * Flush all session budgets to disk for persistence across daemon restarts.
 */
export function flushBudgets(): void {
  try {
    const succDir = getSuccDir();
    const filePath = path.join(succDir, 'session-tokens.json');
    const data: Record<string, TokenBudgetEntry> = {};
    for (const [sessionId, budget] of budgets) {
      data[sessionId] = budget;
    }
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
  } catch {
    // Non-critical — budgets are ephemeral
  }
}

/**
 * Load budgets from disk (daemon startup).
 */
export function loadBudgets(): void {
  try {
    const succDir = getSuccDir();
    const filePath = path.join(succDir, 'session-tokens.json');
    if (fs.existsSync(filePath)) {
      const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
      for (const [sessionId, budget] of Object.entries(data)) {
        budgets.set(sessionId, budget as TokenBudgetEntry);
      }
    }
  } catch {
    // Non-critical
  }
}

/**
 * Remove budget for a session (session ended).
 */
export function removeBudget(sessionId: string): void {
  budgets.delete(sessionId);
}

/**
 * Get all active session budgets (for status reporting).
 */
export function getAllBudgets(): Map<string, TokenBudgetEntry> {
  return new Map(budgets);
}
