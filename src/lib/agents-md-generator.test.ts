/**
 * AGENTS.md Generator Tests (Phase 7.3)
 */

import { describe, it, expect } from 'vitest';
import { DEFAULT_AGENTS_MD_CONFIG } from './agents-md-generator.js';

describe('AGENTS.md Generator', () => {
  describe('Default config', () => {
    it('should have sensible defaults', () => {
      expect(DEFAULT_AGENTS_MD_CONFIG.enabled).toBe(false);
      expect(DEFAULT_AGENTS_MD_CONFIG.max_entries).toBe(50);
      expect(DEFAULT_AGENTS_MD_CONFIG.min_quality).toBe(0.4);
      expect(DEFAULT_AGENTS_MD_CONFIG.include_types).toContain('dead_end');
      expect(DEFAULT_AGENTS_MD_CONFIG.include_types).toContain('decision');
      expect(DEFAULT_AGENTS_MD_CONFIG.include_types).toContain('pattern');
      expect(DEFAULT_AGENTS_MD_CONFIG.include_types).toContain('learning');
    });

    it('should not include observation or error by default', () => {
      expect(DEFAULT_AGENTS_MD_CONFIG.include_types).not.toContain('observation');
      expect(DEFAULT_AGENTS_MD_CONFIG.include_types).not.toContain('error');
    });
  });

  describe('Dead-end formatting', () => {
    it('should extract approach and reason from DEAD END format', () => {
      const content =
        'DEAD END: Tried "Using Redis for sessions" — Failed because: Memory usage too high';
      const match = content.match(/DEAD END: Tried "([^"]+)" — Failed because: (.+)/s);

      expect(match).not.toBeNull();
      expect(match![1]).toBe('Using Redis for sessions');
      expect(match![2]).toBe('Memory usage too high');
    });

    it('should handle multi-line dead-end content', () => {
      const content =
        'DEAD END: Tried "Worker threads for parsing" — Failed because: Serialization overhead\nContext: tested with 1000 files';
      const match = content.match(/DEAD END: Tried "([^"]+)" — Failed because: (.+)/s);

      expect(match).not.toBeNull();
      expect(match![1]).toBe('Worker threads for parsing');
      expect(match![2]).toContain('Serialization overhead');
    });

    it('should handle non-standard dead-end content gracefully', () => {
      const content = 'Some dead-end that does not follow the format';
      const match = content.match(/DEAD END: Tried "([^"]+)" — Failed because: (.+)/s);

      // Falls back to regular formatting
      expect(match).toBeNull();
    });
  });

  describe('Entry truncation', () => {
    it('should truncate long entries at 200 chars', () => {
      const longContent = 'A'.repeat(250);
      const truncated =
        longContent.length > 200 ? longContent.substring(0, 200) + '...' : longContent;

      expect(truncated.length).toBe(203); // 200 + "..."
      expect(truncated.endsWith('...')).toBe(true);
    });

    it('should not truncate short entries', () => {
      const shortContent = 'Short memory content';
      const truncated =
        shortContent.length > 200 ? shortContent.substring(0, 200) + '...' : shortContent;

      expect(truncated).toBe(shortContent);
    });
  });

  describe('Section ordering', () => {
    it('dead-ends should come first in type priority', () => {
      const typeOrder: Record<string, number> = {
        dead_end: 0,
        decision: 1,
        pattern: 2,
        learning: 3,
      };

      const sorted = ['learning', 'dead_end', 'decision', 'pattern'].sort(
        (a, b) => (typeOrder[a] ?? 4) - (typeOrder[b] ?? 4)
      );

      expect(sorted[0]).toBe('dead_end');
      expect(sorted[1]).toBe('decision');
      expect(sorted[2]).toBe('pattern');
      expect(sorted[3]).toBe('learning');
    });
  });

  describe('Markdown format', () => {
    it('should have correct header format', () => {
      const header = '# AGENTS.md';
      const subheader = '> Auto-generated from succ memories. Do not edit manually.';

      expect(header).toBe('# AGENTS.md');
      expect(subheader).toContain('Auto-generated');
      expect(subheader).toContain('Do not edit manually');
    });

    it('should have correct section headers', () => {
      const sections = [
        '## Dead Ends (Do NOT retry these)',
        '## Key Decisions',
        '## Patterns & Conventions',
        '## Important Learnings',
      ];

      expect(sections[0]).toContain('Dead Ends');
      expect(sections[0]).toContain('Do NOT retry');
    });

    it('entry format should include memory ID for traceability', () => {
      const entry = `- Some content _(id: 42, 2/6/2026)_`;
      expect(entry).toContain('id: 42');
    });

    it('entry format should include date', () => {
      const date = new Date('2026-02-06').toLocaleDateString();
      const entry = `- Some content _(id: 1, ${date})_`;
      expect(entry).toContain(date);
    });
  });

  describe('Footer', () => {
    it('should include entry count and quality threshold', () => {
      const footer = `*Generated by succ. Entries: 15. Source: project memories with quality >= 0.4*`;
      expect(footer).toContain('Entries: 15');
      expect(footer).toContain('quality >= 0.4');
    });
  });

  describe('Entry counting', () => {
    it('should count list items correctly', () => {
      const content = [
        '# AGENTS.md',
        '## Dead Ends',
        '- Dead end 1',
        '- Dead end 2',
        '## Decisions',
        '- Decision 1',
      ].join('\n');

      const count = (content.match(/^- /gm) || []).length;
      expect(count).toBe(3);
    });

    it('should return 0 for empty content', () => {
      const content = '# AGENTS.md\n\n';
      const count = (content.match(/^- /gm) || []).length;
      expect(count).toBe(0);
    });
  });
});
